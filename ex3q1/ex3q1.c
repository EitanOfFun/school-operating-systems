#include <stdio.h>#include <sys/types.h>#include <sys/ipc.h>#include <sys/shm.h>#include <stdlib.h>#include <unistd.h>#define PATH "/tmp"#define C 'b'typedef struct {    key_t key;    int shm_id;    void* shm_ptr;} Shm;Shm mallocShm(const char* path, char c, int permissions, size_t size);void deleteShm(Shm s);void clearShm(Shm s);int comparator(const void* a, const void* b);void myMergeSort(int *nums, int size, int splitLevel, int startIndex);void myRecMerge(int *nums, int size, int splitLevel, int startIndex);void myMerge(int *nums, int size);void myMerge(int *nums, int size) {    int mergedNums[size];    int i = 0, j = size / 2, k;    for (k = 0; i < size / 2 && j < size; k++) {        if (nums[i] < nums[j]) {            mergedNums[k] = nums[i];            i++;        }        else {            mergedNums[k] = nums[j];            j++;        }    }    while (i < size / 2) {        mergedNums[k] = nums[i];        i++;        k++;    }    while (j < size) {        mergedNums[k] = nums[j];        j++;        k++;    }    for (i = 0; i < size; ++i)        nums[i] = mergedNums[i];}int comparator(const void* a, const void* b) {    int num1 = *(const int *)a;    int num2 = *(const int *)b;    if (num1 > num2)        return 1;    if (num1 == num2)        return 0;    return -1;}void myRecMerge(int *nums, int size, int splitLevel, int startIndex) {    if (splitLevel == 1)        return;    else {        myRecMerge(nums, size / 2, splitLevel / 2, startIndex);        myRecMerge(nums, size / 2, splitLevel / 2, startIndex + (size / 2));        myMerge(nums + startIndex, size);    }}void myMergeSort(int *nums, int size, int splitLevel, int startIndex) {    if (splitLevel == 1) {        pid_t pid = fork();        if (pid == -1)            perror("fork() failed");        else if (pid == 0) {            printf("\nCreate a process: %d", getpid());            mergesort(nums + startIndex, size, sizeof(int), comparator);            exit(EXIT_SUCCESS);        }    } else {        myMergeSort(nums, size / 2, splitLevel / 2, startIndex);        myMergeSort(nums, size / 2, splitLevel / 2, startIndex + (size / 2));    }}int main(int argc, char **argv) {    int size, splitLevel;    FILE* fp = fopen(argv[1], "r");    fscanf(fp, "%d", &size);    fscanf(fp, "%d", &splitLevel);    int nums[size], i;    for (i = 0; i < size - 1; ++i)        fscanf(fp, "%d,", &nums[i]);    fscanf(fp, "%d", &nums[i]);    Shm shm = mallocShm(PATH, C, IPC_CREAT | IPC_EXCL | 0600, sizeof(int)*(size + 1));    for (i = 0; i < size; ++i)        ((int*)shm.shm_ptr)[i] = nums[i];    printf("Amount of numbers that sort: %d\n", size);    printf("Degree of parallelism: %d\n", splitLevel);    printf("Before sort: %d", ((int*)shm.shm_ptr)[0]);    for (i = 1; i < size; ++i)        printf(",%d", ((int*)shm.shm_ptr)[i]);    fflush(stdout);    myMergeSort((int *) shm.shm_ptr, size, splitLevel, 0);    for (int j = 0; j < splitLevel; ++j)        wait(NULL);    myRecMerge((int *) shm.shm_ptr, size, splitLevel, 0);    printf("\nAfter sort: %d", ((int*)shm.shm_ptr)[0]);    for (i = 1; i < size; ++i)        printf(",%d", ((int*)shm.shm_ptr)[i]);    deleteShm(shm);    clearShm(shm);}Shm mallocShm(const char* path, char c, int permissions, size_t size) {    key_t key ;    if ((key = ftok(path, c)) == -1) {        perror("ftok() failed");        exit(EXIT_FAILURE);    }    int shm_id = shmget(key, size, permissions) ;    if (shm_id == -1) {        perror("shmget() failed");        exit(EXIT_FAILURE);    }    char *shm_ptr = (char *) shmat(shm_id, NULL, 0);    if (shm_ptr == (char *) -1) {        perror("shmat() failed");        exit(EXIT_FAILURE);    }    Shm shm = {key, shm_id, shm_ptr};    return shm;}void deleteShm(Shm s) {    shmdt(s.shm_ptr);}void clearShm(Shm s) {    if (shmctl(s.shm_id,IPC_RMID, NULL) == -1) {        perror("shmctl() failed");        exit(EXIT_FAILURE);    }}